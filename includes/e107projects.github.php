<?php

/**
 * @file
 * Class for handling Github requests.
 */

// Common functions.
e107_require_once(e_PLUGIN . 'e107projects/includes/e107projects.common.php');
// This file is generated by Composer.
e107_require_once(e_PLUGIN . 'e107projects/vendor/autoload.php');

// TODO - use Redis cache server instead of CachedHttpClient?
// use Cache\Adapter\Redis\RedisCachePool;
use \Github\HttpClient\CachedHttpClient;
use \Github\Client;
use \Github\ResultPager;

/**
 * Class e107projectsGithub.
 */
class e107projectsGithub
{

	/**
	 * Plugin preferences.
	 *
	 * @var
	 */
	private $plugPrefs;

	/**
	 * @var mixed
	 */
	private $client_id;

	/**
	 * @var mixed
	 */
	private $secret;

	/**
	 * @var
	 */
	private $accessToken;

	/**
	 * @var Client
	 */
	private $client;

	/**
	 * @var ResultPager
	 */
	private $paginator;

	/**
	 * @var bool
	 */
	private $authenticated = false;

	/**
	 * Constructor.
	 */
	public function __construct($access_token = null, $use_cache = true)
	{
		// Get plugin preferences.
		$this->plugPrefs = e107::getPlugConfig('e107projects')->getPref();
		// Get Social plugin config.
		$social_login = e107::getConfig()->get('social_login');

		// Use Client ID + Secret for higher (5000 request/hour) rate limit.
		$this->client_id = varset($social_login['Github']['keys']['id'], '');
		$this->secret = varset($social_login['Github']['keys']['secret'], '');

		// Github Access Token for the User.
		$this->accessToken = $access_token;

		if($use_cache === true)
		{
			// Get Cache directory for caching HTTP request in order to decrease number of
			// requests.
			$cache_dir = e107::getInstance()->e107_dirs['CACHE_DIRECTORY'] . 'e107projects';

			// Get Cached HTTP Client.
			$cache = new CachedHttpClient(array(
				'cache_dir' => $cache_dir,
			));

			// Get Github Client with Cached HTTP Client.
			$this->client = new Client($cache);
		}
		else
		{
			// Client without caching.
			$this->client = new Client();
		}

		// If Access Token is provided, we try to authenticate with it.
		if(!empty($this->accessToken))
		{
			// If user token is valid, we authenticates with it.
			if(e107projects_access_token_is_valid($this->accessToken))
			{
				// Use Access Token for higher (5000 request/hour) rate limit.
				$this->client->authenticate($this->accessToken, null, Client::AUTH_URL_TOKEN);
				$this->authenticated = true;
			}
		}

		// If authentication with Access Token failed, we use our Client ID + Secret.
		if(!$this->authenticated)
		{
			// Use Client ID + Secret for higher (5000 request/hour) rate limit.
			$this->client->authenticate($this->client_id, $this->secret, Client::AUTH_URL_CLIENT_ID);
		}

		// Use Result Pager.
		$this->paginator = new ResultPager($this->client);
	}

	/**
	 * Get rate limits
	 *
	 * @return array
	 */
	public function getRateLimits()
	{
		$rateLimitAPI = new \Github\Api\RateLimit($this->client);
		$rateLimits = $rateLimitAPI->getRateLimits();
		return $rateLimits;
	}
	
	/**
	 * Get extended information about a user by its username.
	 *
	 * @link https://developer.github.com/v3/orgs/
	 *
	 * @param string $username
	 *  The username to show.
	 *
	 * @return array
	 *  Information about organizations that user belongs to.
	 */
	public function getUserOrganizations($username)
	{
		if(empty($username))
		{
			return array();
		}

		$userAPI = $this->client->api('user');
		return $this->paginator->fetchAll($userAPI, 'organizations', array($username));
	}

	/**
	 * Get the repositories of a user.
	 *
	 * @link http://developer.github.com/v3/repos/
	 *
	 * @param string $username
	 *  The username.
	 * @param string $type
	 *  Role in the repository. all, owner, member
	 * @param string $sort
	 *  Sort by.
	 * @param string $direction
	 *  Direction of sort, asc or desc.
	 *
	 * @return array|boolean
	 *  List of the user repositories, or false.
	 */
	public function getUserRepositories($username, $type = 'owner', $sort = 'full_name', $direction = 'asc')
	{
		if(empty($username))
		{
			return false;
		}

		$userAPI = $this->client->api('user');
		return $this->paginator->fetchAll($userAPI, 'repositories', array($username, $type, $sort, $direction));
	}

	/**
	 * Get the readme URL for a repository by its username and repository name.
	 *
	 * @link http://developer.github.com/v3/repos/contents/#get-the-readme
	 *
	 * @param string $username
	 *  The user who owns the repository.
	 * @param string $repository
	 *  The name of the repository.
	 *
	 * @return string
	 *  The readme URL.
	 */
	public function getReadmeURL($username, $repository)
	{
		$readme = '';

		if(empty($username) || empty($repository))
		{
			return $readme;
		}

		$reopAPI = $this->client->api('repo');

		$url = 'https://api.github.com/repos/' . $username . '/' . $repository . '/readme/';

		$response = e107projects_http_request($url);
		if(!empty($response->code) && $response->code != 404)
		{
			$data = $this->paginator->fetchAll($reopAPI, 'readme', array($username, $repository));
		}

		if(isset($data) && !empty($data['download_url']))
		{
			$readme = $data['download_url'];
		}

		return $readme;
	}

	/**
	 * Count commits by repository.
	 *
	 * @param string $username
	 *  The user who owns the repository.
	 * @param string $repository
	 *  The name of the repository.
	 *
	 * @return int
	 */
	public function countCommits($username, $repository)
	{
		$count = 0;

		$contributors = $this->getContributors($username, $repository, true);

		foreach($contributors as $contributor)
		{
			$count += (int) varset($contributor['contributions'], 0);
		}

		return $count;
	}

	/**
	 * Get the contributors of a repository.
	 *
	 * @link http://developer.github.com/v3/repos/
	 *
	 * @param string $username
	 *  The user who owns the repository.
	 * @param string $repository
	 *  The name of the repository.
	 * @param bool $includingAnonymous
	 *  By default, the list only shows GitHub users.
	 *  You can include non-users too by setting this to true
	 *
	 * @return array
	 *  List of the repo contributors.
	 */
	public function getContributors($username, $repository, $includingAnonymous = false)
	{
		if(empty($username) || empty($repository))
		{
			return array();
		}

		$reopAPI = $this->client->api('repo');
		return $this->paginator->fetchAll($reopAPI, 'contributors', array($username, $repository, $includingAnonymous));
	}

	/**
	 * Get the releases of a repository.
	 *
	 * @param string $username
	 *  The user who owns the repository.
	 * @param string $repository
	 *  The name of the repository.
	 *
	 * @return array
	 *  List of the repo contributors.
	 */
	public function getReleases($username, $repository)
	{
		if(empty($username) || empty($repository))
		{
			return array();
		}

		$releaseAPI = new \Github\Api\Repository\Releases($this->client);
		return $this->paginator->fetchAll($releaseAPI, 'all', array($username, $repository));
	}

	/**
	 * @param $username
	 * @param $repository
	 * @return array
	 */
	public function createHook($username, $repository)
	{
		if(empty($username) || empty($repository))
		{
			return array();
		}

		if(empty($this->accessToken))
		{
			return array();
		}

		// Assemble endpoint URL for webhook.
		$endpoint = rtrim(SITEURL, '/') . e107::url('e107projects', 'github/callback');

		// Prepare webhook details.
		$params = array(
			'name'   => 'web',
			'active' => true,
			'events' => array(
				'*', // Any time any event is triggered.
			),
			'config' => array(
				'url'          => $endpoint,
				'content_type' => 'json',
				'secret'       => varset($this->plugPrefs['github_secret'], ''),
			),
		);

		// Get the Webhook API.
		$hookAPI = new \Github\Api\Repository\Hooks($this->client);

		// Get all webhooks.
		$hooks = $hookAPI->all($username, $repository);

		// This will contain details about we our hook.
		$details = false;

		// Check if hook already exists.
		foreach($hooks as $hook)
		{
			if($hook['config']['url'] == $endpoint)
			{
				$details = $hook;
			}
		}

		// If hook does not exist.
		if(!$details)
		{
			$details = $hookAPI->create($username, $repository, $params);
		}

		if(isset($details['id']))
		{
			$db = e107::getDb();
			$tp = e107::getParser();
			$event = e107::getEvent();

			$events = implode(',', $details['events']);

			// Insert contributor details.
			$insert = array(
				'data' => array(
					'hook_id'           => (int) $details['id'],
					'hook_project_user' => $tp->toDB($username),
					'hook_project_name' => $tp->toDB($repository),
					'hook_name'         => $tp->toDB($details['name']),
					'hook_active'       => (int) $details['active'],
					'hook_events'       => $tp->toDB($events),
					'hook_config_url'   => $tp->toDB($details['config']['url']),
					'hook_config_type'  => $tp->toDB($details['config']['content_type']),
					'hook_created_at'   => strtotime($details['created_at']),
					'hook_updated_at'   => strtotime($details['updated_at']),
					'hook_access_token' => $tp->toDB($this->accessToken),
				),
			);

			if($db->insert('e107projects_hook', $insert, false))
			{
				$event->trigger('e107projects_hook_created', $insert['data']);
			}
		}
	}

	/**
	 * Try to delete hook.
	 *
	 * @param string $username
	 * @param string $repository
	 * @param int $hook_id
	 *  Hook ID.
	 *
	 * @return bool
	 */
	public function deleteHook($username, $repository, $hook_id)
	{
		if(empty($username) || empty($repository) || empty($hook_id))
		{
			return false;
		}

		if(empty($this->accessToken))
		{
			return false;
		}

		// Get the Webhook API.
		$hookAPI = new \Github\Api\Repository\Hooks($this->client);
		$hookAPI->remove($username, $repository, $hook_id);
		// Response: Status: 204 No Content
		return true;
	}

	/**
	 * Get Github username by e107 user ID.
	 *
	 * @param int $user_id
	 *  User ID in e107.
	 *
	 * @return string|boolean
	 */
	public function getGithubUsername($user_id)
	{
		// If no user ID provided, we use current user's ID.
		if($user_id === null)
		{
			$user_id = USERID;
		}

		$db = e107::getDb();
		$tp = e107::getParser();

		// First we try to get user name from database.
		$user = $db->retrieve('e107projects_contributor', '*', 'contributor_id = ' . (int) $user_id);
		if(varset($user['contributor_name'], false))
		{
			return $user['contributor_name'];
		}

		// If user name is not found in database, we try to request it from Github
		// using Github User ID from XUP.
		$user = e107::user($user_id);
		$userXUP = varset($user['user_xup'], '');
		list($provider, $githubID) = explode('_', $userXUP);

		if($provider != 'Github' || !is_numeric($githubID))
		{
			return false;
		}

		$url = 'https://api.github.com/user/' . $githubID;
		$response = e107projects_http_request($url);

		if(empty($response->error))
		{
			$data = json_decode($response->data);

			// Got it! Save user details to database for later use.
			if(varset($data->login, false))
			{
				$contributor_gid = $db->retrieve('e107projects_contributor', 'contributor_gid', 'contributor_name = "' . $tp->toDB($data->login) . '"');

				// If contributor exists in database, we update...
				if((int) $contributor_gid > 0)
				{
					// Update contributor details.
					$update = array(
						'data'  => array(
							'contributor_id'     => (int) $user_id,
							'contributor_gid'    => (int) $data->id,
							'contributor_avatar' => $tp->toDB($data->avatar_url),
							'contributor_type'   => $tp->toDB($data->type),
						),
						'WHERE' => 'contributor_name = "' . $tp->toDB($data->login) . '"'
					);

					$db->update('e107projects_contributor', $update, false);
				}
				else
				{
					// Insert contributor details.
					$insert = array(
						'data' => array(
							'contributor_id'     => (int) $user_id,
							'contributor_gid'    => (int) $data->id,
							'contributor_name'   => $tp->toDB($data->login),
							'contributor_avatar' => $tp->toDB($data->avatar_url),
							'contributor_type'   => $tp->toDB($data->type),
						),
					);

					$db->insert('e107projects_contributor', $insert, false);
				}

				return $data->login;
			}
		}

		return false;
	}

}
